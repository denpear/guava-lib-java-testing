package denpear.javatrain.learn.comparator;

import org.junit.Test;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class BinarySearchTest {

    /**
     * 15. D. Список отсортирован в порядке убывания. Однако поиск в нем выполняется с использованием порядка по умолчанию,
     * который отсортирован по возрастанию.
     * binarySearch() требует, чтобы в обоих случаях использовался один и тот же порядок сортировки.
     * Поэтому предусловие для binarySearch() не выполняется, и результат не определен (return -1).
     * [7,5,4,1] - как если бы нужно вставить 1 в индекс 0, так как оно меньше любого из чисел в списке.
     * Отрицание 0 по-прежнему равно 0, а вычитание 1 дает нам -1.
     */

    /**
     * binarySearch - это:
     * Выполняет поиск указанного списка для указанного объекта с использованием алгоритма бинарного поиска.
     * Список должен быть отсортирован по возрастанию в соответствии с естественным порядком следования его элементов (как в методе sort(List)) до выполнения этого вызова.
     * Если список не отсортирован, результат не определен. Если список содержит несколько элементов, равных указанному объекту, то нет гарантии, какой из них будет найден.
     * Этот метод выполняется за log(n) время для списка "случайного доступа" (который обеспечивает почти постоянный позиционный доступ).
     * Если указанный список не реализует интерфейс RandomAccess и является большим,
     * этот метод будет выполнять двоичный поиск на основе итератора, который выполняет O(n) обходов ссылок и O(log n) сравнений элементов.
     *
     * Параметры:
     * list - список для поиска.
     * key - ключ для поиска.
     * Параметры типа:
     * <T> - класс объектов в списке.
     *
     * Возвращает:
     * индекс искомого ключа, если он содержится в списке; иначе (-(точка вставки) - 1).
     * Точка вставки определяется как точка, в которой ключ будет вставлен в список: индекс первого элемента больше ключа, или list.size(),
     * если все элементы в списке меньше указанного ключа. Обратите внимание, что это гарантирует, что возвращаемое значение будет >= 0, если и только если ключ будет найден.
     * Выбрасывает:
     * ClassCastException - если список содержит элементы, которые не являются взаимосопоставимыми (например, строки и целые числа),
     * или ключ поиска не является взаимосопоставимым с элементами списка.
     */
    @Test
    public void onCollectionsAndComparator() {
        Comparator<Integer> comparator = (o1, o2) -> o2 - o1; //Список отсортирован в порядке убывания.
       // Comparator<Integer> comparator = (o1, o2) -> o1 - o2; //Список отсортирован в порядке возрастания.
        List<Integer> list = Arrays.asList(5, 4, 7, 1);
        Collections.sort(list, comparator); //[7,5,4,1]
        System.out.println(Collections.binarySearch(list, 1)); // return -1
    }

    /**
     * ВАЖНО: У массивов есть несколько особенностей:
     *
     * 1.  Они могут хранить переменные только одного типа;
     *
     * 2. Размер массива нельзя поменять;
     *
     * 3.  Массив имеет длину;
     *
     * 4. Элементы массивов имеют индексы, по которым к ним и обращаются в случае необходимости;
     *
     * 5. Номер первого элемента массива - 0;
     *
     * 6. Можно создавать пустые массивы, и "положить" в них элементы потом.
     *
     * Строка 12 сортирует массив, поскольку двоичный поиск предполагает, что входные данные отсортированы.
     * Строка 13 печатает индекс, по которому найдено совпадение. В строке 14 выводится значение на единицу меньше, чем отрицаемый индекс,
     * куда нужно вставить запрашиваемое значение.
     * Число 3 должно быть вставлено в индекс 1 (после числа 1, но перед числом 6). Отрицание этого значения дает нам -1, а вычитание 1 дает -2.
     */

    @Test
    public void testBinarySearchOnArray(){
         int[] numbers = {6,9,1,8};
         Arrays.sort(numbers); // [1,6,8,9]
         System.out.println(Arrays.binarySearch(numbers, 6)); // 1
         System.out.println(Arrays.binarySearch(numbers, 3)); // -2
    }

    /**
     * ВАЖНО: List - это как изменяемый по размеру массив
     * Аналогично, нам нужно было сначала отсортировать. В строке 17 выводится индекс совпадения.
     * Для строки 18 нам нужно вставить 2 в индекс 0, так как оно меньше любого из чисел в списке.
     * Отрицание 0 по-прежнему равно 0, а вычитание 1 дает нам -1.
     */

    @Test
    public void testBinarySearchOnList(){
         List<Integer> list = Arrays.asList(9,7,5,3);
         Collections.sort(list); // [3, 5, 7, 9].
         System.out.println(Collections.binarySearch(list, 3)); // 0
         System.out.println(Collections.binarySearch(list, 2)); // -1
    }

}

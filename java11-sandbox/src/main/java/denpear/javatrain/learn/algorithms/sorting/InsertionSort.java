package denpear.javatrain.learn.algorithms.sorting;

import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;

/**
 * Название	            Лучшее время	Среднее	Худшее	Память	Устойчивость	Обмены (в среднем)
 * "Сортировка вставками
 * (Insertion Sort)"	        O(n)	O(n^2)	O(n^2)	O(1)	        Да	        O(n^2)
 * <p>
 * Описание:
 * На каждом шаге алгоритма мы выбираем один из элементов входных данных
 * и вставляем его на нужную позицию в уже отсортированной части массива до тех пор,
 * пока весь набор входных данных не будет отсортирован.
 * <p>
 * Этот алгоритм разделяет оригинальный массив на сортированный и несортированный подмассивы.
 * <p>
 * Длина сортированной части равна 1 в начале и соответствует первому (левому) элементу в массиве.
 * После этого остается итерировать массив и расширять отсортированную часть массива одним элементом с каждой новой итерацией.
 * <p>
 * После расширения новый элемент помещается на свое место в отсортированном подмассиве.
 * Это происходит путём сдвига всех элементов вправо, пока не встретится элемент, который не нужно двигать.
 * <p>
 * В приведенном ниже массиве жирная часть отсортирована в порядке возрастания. Посмотрите что произойдет в этом случае:
 * <p>
 * 3 5 7 8 4 2 1 9 6: выбираем 4 и помним, что это элемент, который нужно вставить. 8 > 4, поэтому сдвигаем.
 * 3 5 7 x 8 2 1 9 6: здесь x – нерешающее значение, так как элемент будет перезаписан
 * (на 4, если это подходящее место, или на 7, если смещение). 7 > 4, поэтому сдвигаемся.
 * 3 5 x 7 8 2 1 9 6
 * 3 x 5 7 8 2 1 9 6
 * 3 4 5 7 8 2 1 9 6
 * Теперь вы видите, что отсортированная часть дополнилась элементом.
 * Каждая следующая итерация делает то же самое, и к концу вы получите отсортированный массив!
 */


public class InsertionSort {
    /**
     * Временная сложность:
     * Вернемся к худшему сценарию – к массиву, отсортированному в убывающем порядке.
     * <p>
     * В этом случае каждая итерация сдвигает отсортированный массив на единицу O(n).
     * Придется делать это для каждого элемента в каждом массиве, что приведет к сложности равной O(n^2).
     *
     * @param array
     */
    public static void insertionSort(int[] array) {
        System.out.println("До сортировки: " + Arrays.toString(array));
        for (int i = 1; i < array.length; i++) { // решаем начинать с 2-го/более правого числа в массиве
            int currentInt = array[i]; // местоблюститель 2-го/более правого числа в массиве
            int j = i - 1;
            while (j >= 0 && currentInt < array[j]) { //правое делаем правее на одну ячейку пока не найдем место ВСТАВКИ слева
                array[j + 1] = array[j]; // array[j] - 1-е (самое левое) число в массиве записываем на 2-е место,
                j--;
            }
            // в этой точке мы вышли, так что j так же -1
            // или в первом элементе, где текущий currentInt >= array[j]
            array[j + 1] = currentInt; // на 1-е место теперь можно записать бывшее 2-е число из переменной, бывшее правое пишем левее
        }
        System.out.println("После сортировки: " + Arrays.toString(array));
    }


    public static void main(String[] args) {
        int[] ints = IntStream.generate(() -> ThreadLocalRandom.current().nextInt(1000)).limit(6).toArray();
        InsertionSort.insertionSort(ints);
    }

}

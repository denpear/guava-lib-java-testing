package denpear.javatrain.learn.algorithms.sorting;

import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;

/**
 * Название	            Лучшее время	Среднее	Худшее	Память	Устойчивость	Обмены (в среднем)
 * "Сортировка пузырьком
 * (Bubble Sort)"	        O(n)	       O(n)	O(n^2)	  O(1)	Да	            O(n^2)
 * <p>
 * Описание: Пузырьковая сортировка (сортировка пузырьком, сортировка простыми обменами)
 * Алгоритм состоит в повторяющихся проходах по сортируемому массиву.
 * На каждой итерации последовательно сравниваются соседние элементы,
 * и, если порядок в паре неверный, то элементы меняют местами.
 *
 * <p>
 * Вот шаги для сортировки массива чисел от наименьшего к большему:
 * <p>
 * 4 2 1 5 3: два первых элемента расположены в массиве в неверном порядке. Меняем их.
 * 2 4 1 5 3: вторая пара элементов тоже «не в порядке». Меняем и их.
 * 2 1 4 5 3: а эти два элемента в верном порядке (4 < 5), поэтому оставляем как есть.
 * 2 1 4 5 3: очередная замена.
 * 2 1 4 3 5: результат после одной итерации.
 * Для полной сортировки нужен еще один шаг. Третья итерация пройдет уже без замены. Так вы поймете, что массив отсортирован.
 * <p>
 * Но причём тут пузырьки? Посмотрите снова на пример, и вы увидите,
 * что алгоритм как бы смещается вправо.
 * По этому поведению элементов в массиве и возникла аналогия с «пузырьками», всплывающими на «поверхность».
 */

public class BubbleSort {

    /**
     * Временная сложность:
     * Рассмотрим наихудший сценарий. Вот в чем вопрос: сколько итераций нужно для сортировки всего массива? Пример:
     * <p>
     * 5 4 3 2 1
     * При первой итерации 5 «всплывает на поверхность», при этом остальные элементы остаются в порядке убывания.
     * Если вы хотите получить отсортированный массив, придется делать по одной итерации для каждого элемента,
     * кроме 1, и еще одну итерацию для проверки, что в сумме составляет 5 итераций.
     * <p>
     * Расширьте это утверждение для массива из n элементов, и получите n итераций. В коде это означает,
     * что цикл while будет запускаться максимум n раз.
     * <p>
     * Каждая n-ая итерация по всему массиву (цикл for в коде) означает,
     * что временная сложность в наихудшем случае будет равна O(n^2).
     *
     * @param array
     */

    public static void bubbleSort(int[] array) {
        System.out.println("До сортировки: " + Arrays.toString(array));
        boolean sorted = false;
        int temp;
        while (!sorted) {
            sorted = true;
            for (int i = 0; i < array.length - 1; i++) {
                if (array[i] > array[i + 1]) {
                    temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                    sorted = false;
                }
            }
        }
        System.out.println("После сортировки: " + Arrays.toString(array));
    }


    public static void main(String[] args) {
        int[] ints = IntStream.generate(() -> ThreadLocalRandom.current().nextInt(1000)).limit(6).toArray();
        BubbleSort.bubbleSort(ints);
    }

}
